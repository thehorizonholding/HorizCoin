// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

interface IUniswapV2Router {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

contract OmegaConquestTreasury is Ownable, ReentrancyGuard {
    IERC20 public immutable HORIZ;
    address public constant ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;

    mapping(address => bool) public approvedRWA;

    event RWAApproved(address indexed rwa);
    event RWAConquered(address indexed rwa, uint256 horizIn, uint256 rwaOut);
    event FundsRescued(address indexed token, uint256 amount);

    constructor(address _horiz) Ownable(msg.sender) {
        require(_horiz != address(0), "Invalid HORIZ address");
        HORIZ = IERC20(_horiz);
    }

    function approveRWA(address rwa) external onlyOwner {
        require(rwa != address(0), "Invalid RWA");
        approvedRWA[rwa] = true;
        emit RWAApproved(rwa);
    }

    function conquerRWA(uint256 amountHORIZ, address targetRWA, uint256 minOut) 
        external onlyOwner nonReentrant 
    {
        require(approvedRWA[targetRWA], "RWA not approved");
        require(amountHORIZ > 0, "Zero amount");

        HORIZ.approve(ROUTER, amountHORIZ);

        address[] memory path = new address[](2);
        path[0] = address(HORIZ);
        path[1] = targetRWA;

        uint[] memory amounts = IUniswapV2Router(ROUTER).swapExactTokensForTokens(
            amountHORIZ,
            minOut,
            path,
            address(this),
            block.timestamp + 1800
        );

        emit RWAConquered(targetRWA, amountHORIZ, amounts[1]);
    }

    function rescue(address token, uint256 amount) external onlyOwner {
        IERC20(token).transfer(owner(), amount);
        emit FundsRescued(token, amount);
    }
}
