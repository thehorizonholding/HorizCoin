
---

### Contracts Folder (`contracts/`)

#### `GlobalLBO.sol` (Your code + complete fixes)
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol";
import "@aave/core-v3/contracts/interfaces/IPool.sol";
import "@aave/core-v3/contracts/flashloan/base/FlashLoanReceiverBase.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./interfaces/IHorizBondingCurve.sol";
import "./interfaces/IExchangeWrapper.sol";
import "./interfaces/IVampireMigrator.sol";

contract GlobalLBO is FlashLoanReceiverBase, Ownable {
    IPoolAddressesProvider public constant POOL_ADDRESSES_PROVIDER = IPoolAddressesProvider(0x2f39d218133AFaB8F2B819B1066c7E434Ad94E9e);
    address public constant USDC = 0xA0b869198765DE67f4B1e9eDeA11F9D3A4b1e9eDe;
    address public googlToken = 0x...; // Update via setter
    address public horizCurve = 0x...; // Update via setter
    
    address public vampireMigrator;

    uint256 public loopCount;
    uint256 public constant MAX_LOOPS = 10;

    struct LBOParams {
        uint256 amountToAcquire;
        uint256 minHorizOutput;
    }

    event ConquestInitiated(uint256 loanAmount, uint256 loops);
    event LBOExecuted(uint256 acquired, uint256 horizMinted, uint256 profit);

    constructor(address _owner, address _migrator) Ownable(_owner) {
        vampireMigrator = _migrator;
    }

    function setGooglToken(address _token) external onlyOwner { googlToken = _token; }
    function setHorizCurve(address _curve) external onlyOwner { horizCurve = _curve; }

    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external override returns (bool) {
        require(msg.sender == address(POOL), "Unauthorized");
        require(initiator == address(this), "Invalid initiator");

        LBOParams memory lboParams = abi.decode(params, (LBOParams));
        uint256 loanAmount = amounts[0];
        uint256 premium = premiums[0];
        uint256 amountToRepay = loanAmount + premium;

        // 1. Buy RWA (synthetic GOOGL)
        uint256 acquired = IExchangeWrapper(googlToken).swap(assets[0], loanAmount, lboParams.amountToAcquire);
        require(acquired >= lboParams.amountToAcquire * 95 / 100, "Slippage");

        // 2. Deposit to curve
        IERC20(googlToken).approve(horizCurve, acquired);
        uint256 horizMinted = IHorizBondingCurve(horizCurve).deposit(googlToken, acquired);
        require(horizMinted >= lboParams.minHorizOutput, "Insufficient HORIZ");

        // 3. Borrow against collateral
        uint256 borrowAmount = IHorizBondingCurve(horizCurve).borrow(horizMinted, USDC);

        // 4. Check solvency
        uint256 profit = borrowAmount - amountToRepay;
        require(borrowAmount >= amountToRepay, "Insolvency");

        // 5. Repay + rewards
        IERC20(USDC).approve(msg.sender, amountToRepay);
        IERC20(USDC).transfer(owner(), profit);
        if (vampireMigrator != address(0)) IVampireMigrator(vampireMigrator).distributeRewards(profit);

        emit LBOExecuted(acquired, horizMinted, profit);
        return true;
    }

    function initiateConquest(uint256 usdcAmount, uint256 maxLoops) external onlyOwner {
        address[] memory assets = new address[](1);
        assets[0] = USDC;
        uint256[] memory amounts = new uint256[](1);
        amounts[0] = usdcAmount;
        uint256[] memory modes = new uint256[](1);
        modes[0] = 0;

        bytes memory params = abi.encode(LBOParams(usdcAmount, 0));

        POOL.flashLoan(address(this), assets, amounts, modes, address(this), params, 0);

        loopCount += maxLoops;
        emit ConquestInitiated(usdcAmount, maxLoops);
    }
}
